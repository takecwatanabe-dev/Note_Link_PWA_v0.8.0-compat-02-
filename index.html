<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NOTE LINK — v0.8.0 / B-REL6-HF1</title>
<style>
  :root{ --a4w:794px; --a4h:1123px; }
  html,body{height:100%}
  body{margin:0;background:#1b1b1b;color:#f4f4f4;font-family:system-ui,"Noto Sans JP",sans-serif}
  .topbar{height:44px;display:flex;align-items:center;gap:12px;padding:0 14px;background:#111;border-bottom:1px solid #2a2a2a}
  .ver{font-weight:700;letter-spacing:.02em}
  .kbd{font-size:.82rem;color:#9aa}
  .wrap{display:flex}
  .canvas-wrap{position:relative;flex:1;display:flex;justify-content:center;align-items:flex-start;padding:12px 0;overflow:auto;height:calc(100vh - 44px)}
  .a4-stage{
    position:relative;background:#fff;border:1px solid #ddd;box-shadow:0 2px 12px rgba(0,0,0,.35);
    width:var(--a4w);height:var(--a4h);
  }
  canvas{image-rendering:crisp-edges;touch-action:none;-ms-touch-action:none;user-select:none}
  #note{position:absolute;left:0;top:0;width:100%;height:100%}
  #overlay{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}

  /* 消しゴム設定ダイアログ（内部UIのみ追加） */
  dialog#eraserDialog{
    border:none;border-radius:12px;padding:0;max-width:360px;background:#121212;color:#eee;
    box-shadow:0 14px 60px rgba(0,0,0,.6);width:min(92vw,360px)
  }
  .dlg-hd{padding:14px 16px;border-bottom:1px solid #2b2b2b;font-weight:700}
  .dlg-bd{padding:12px 16px;display:grid;gap:14px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .row .label{font-size:.95rem;color:#ccc}
  .seg{display:inline-flex;border:1px solid #3a3a3a;border-radius:10px;overflow:hidden}
  .seg button{background:#1b1b1b;color:#eee;border:none;padding:8px 10px;cursor:pointer}
  .seg button[aria-pressed="true"]{background:#2d2d2d;font-weight:700}
  .stepper{display:inline-flex;align-items:center;gap:6px}
  .stepper button{width:34px;height:34px;border-radius:8px;border:1px solid #3a3a3a;background:#1b1b1b;color:#eee;cursor:pointer}
  input[type="range"]{width:180px}
  .mmnote{font-size:.82rem;color:#9aa}
  .dlg-ft{display:flex;justify-content:flex-end;gap:8px;padding:12px 16px;border-top:1px solid #2b2b2b}
  .dlg-ft button{border:1px solid #3a3a3a;background:#1b1b1b;color:#eee;border-radius:10px;padding:8px 12px;cursor:pointer}

  /* デバッグオーバーレイ（?debug=1 のときだけJSで表示） */
  .dbg{position:fixed;right:8px;top:52px;z-index:9999;background:#111a;border:1px solid #333;padding:8px 10px;border-radius:10px;font:12px/1.4 ui-monospace,monospace;white-space:pre;pointer-events:none}

  @media print{
    body{background:#fff;color:#000}
    .topbar{display:none}
    .canvas-wrap{padding:0;height:auto}
    .a4-stage{width:210mm;height:297mm;border:none;box-shadow:none;margin:0 auto}
  }
</style>
</head>
<body>
  <div class="topbar">
    <div class="ver">NOTE LINK — v0.8.0 / <strong>B-REL6-HF1</strong></div>
    <div class="kbd">（補助）消しゴム設定: Ctrl+E ／ 形状切替: R ／ サイズ: [ / ]</div>
  </div>

  <div class="wrap">
    <main class="canvas-wrap">
      <section class="a4-stage" id="stage">
        <canvas id="note"></canvas>
        <canvas id="overlay"></canvas>
      </section>
    </main>
  </div>

  <dialog id="eraserDialog">
    <div class="dlg-hd">消しゴム 設定</div>
    <div class="dlg-bd">
      <div class="row">
        <div class="label">形状</div>
        <div class="seg" role="group" aria-label="Eraser Shape">
          <button id="shapeCircle" aria-pressed="true">円</button>
          <button id="shapeSquare" aria-pressed="false">四角</button>
        </div>
      </div>
      <div class="row">
        <div class="label">サイズ</div>
        <div class="stepper">
          <button id="sizeDec" aria-label="サイズ縮小">–</button>
          <input type="range" id="sizeRange" min="4" max="200" value="24" />
          <button id="sizeInc" aria-label="サイズ拡大">+</button>
        </div>
      </div>
      <div class="row">
        <div class="label">ガイド表示</div>
        <div class="seg">
          <button id="guideOn"  aria-pressed="true">ON</button>
          <button id="guideOff" aria-pressed="false">OFF</button>
        </div>
      </div>
      <div class="mmnote" id="sizeInfo">現在：24 px（約 6.35 mm）</div>
      <div class="mmnote">ショートカット：形状 <b>R</b> ／ サイズ <b>[</b> <b>]</b> ／ ダイアログ <b>Ctrl+E</b></div>
    </div>
    <div class="dlg-ft"><button id="dlgClose">閉じる</button></div>
  </dialog>

<script>
(() => {
  // ===========================================================
  // 設定（UIは触らず内部だけ）／デバッグ
  // ===========================================================
  const DEFAULTS = {
    penColor: '#000000',
    markerColor: '#FFFF00',
    markerAlpha: 0.5,
    penWidth: 2,
    markerWidth: 18,
    eraser: { shape: 'circle', size: 24, guide: true }
  };
  const qs = new URLSearchParams(location.search);
  const DEBUG = qs.get('debug') === '1';
  const stage = document.getElementById('stage');
  const note  = document.getElementById('note');
  const ov    = document.getElementById('overlay');
  const ctx   = note.getContext('2d');
  const octx  = ov.getContext('2d');

  // デバッグ表示（?debug=1）
  let dbgEl = null, dbg = {};
  function dbgInit(){
    if(!DEBUG) return;
    dbgEl = document.createElement('div'); dbgEl.className='dbg'; document.body.appendChild(dbgEl);
    dbg.log = []; window.addEventListener('error', e=>{ dbg.log.push(String(e.error||e.message)); renderDbg(); });
    window.addEventListener('unhandledrejection', e=>{ dbg.log.push('Promise:'+String(e.reason)); renderDbg(); });
    renderDbg();
  }
  function renderDbg(){
    if(!DEBUG || !dbgEl) return;
    const r = stage.getBoundingClientRect();
    const dpr = DPR();
    dbgEl.textContent =
`DPR=${dpr}
stage=${Math.round(r.width)}x${Math.round(r.height)}
noteWH=${note.width}x${note.height} css=${note.style.width||'-'} x ${note.style.height||'-'}
tool=${state.tool} drawing=${state.drawing}
events: down=${dbg.down||0} move=${dbg.move||0} up=${dbg.up||0}
lastErr: ${dbg.log?.slice(-1)[0]||'-'}`;
  }

  // DPI
  const DPR = () => Math.max(1, window.devicePixelRatio || 1);

  // 実サイズ同期（ResizeObserver + rAF二段）
  function syncSize(){
    const fix = ()=>{
      const r = stage.getBoundingClientRect(); const dpr = DPR();
      const w = Math.max(2, Math.floor(r.width  * dpr));
      const h = Math.max(2, Math.floor(r.height * dpr));
      if(note.width!==w)  note.width=w;
      if(note.height!==h) note.height=h;
      if(ov.width!==w)    ov.width=w;
      if(ov.height!==h)   ov.height=h;
      note.style.width  = r.width + 'px';
      note.style.height = r.height + 'px';
      ov.style.width    = r.width + 'px';
      ov.style.height   = r.height + 'px';
      ctx.lineCap = ctx.lineJoin = 'round';
      renderDbg();
    };
    requestAnimationFrame(()=>requestAnimationFrame(fix));
  }
  const ro = new ResizeObserver(syncSize); ro.observe(stage);
  syncSize(); // 初期

  // 状態
  const state = { tool:'pen', drawing:false, startX:0,startY:0,lastX:0,lastY:0, straight:false, pointerId:null };

  // 設定
  let penColor=DEFAULTS.penColor, markerColor=DEFAULTS.markerColor, markerAlpha=DEFAULTS.markerAlpha;
  let penWidth=DEFAULTS.penWidth, markerWidth=DEFAULTS.markerWidth;
  const eraser = { ...DEFAULTS.eraser };

  // 位置
  function posFromClient(x,y){ const r = note.getBoundingClientRect(); const dpr=DPR(); return {x:(x-r.left)*dpr, y:(y-r.top)*dpr}; }

  // スタイル
  function useStyle(tool){
    if(tool==='pen'){ ctx.globalCompositeOperation='source-over'; ctx.globalAlpha=1; ctx.strokeStyle=penColor; ctx.lineWidth=penWidth*DPR(); }
    else if(tool==='marker'){ ctx.globalCompositeOperation='source-over'; ctx.globalAlpha=markerAlpha; ctx.strokeStyle=markerColor; ctx.lineWidth=markerWidth*DPR(); }
    else{ ctx.globalCompositeOperation='destination-out'; ctx.globalAlpha=1; ctx.lineWidth=eraser.size*DPR(); }
    ctx.lineCap=ctx.lineJoin='round';
  }

  // 基本描画
  function begin(x,y){ state.drawing=true; state.startX=state.lastX=x; state.startY=state.lastY=y; ctx.beginPath(); ctx.moveTo(x,y); renderDbg(); }
  function drag(x,y,straight){ ctx.beginPath(); if(straight){ctx.moveTo(state.startX,state.startY);}else{ctx.moveTo(state.lastX,state.lastY);} ctx.lineTo(x,y); ctx.stroke(); state.lastX=x; state.lastY=y; }
  function end(){ state.drawing=false; renderDbg(); }

  // ガイド
  function guide(x,y){
    octx.clearRect(0,0,ov.width,ov.height);
    if(state.tool!=='eraser'||!eraser.guide) return;
    const s = eraser.size*DPR();
    octx.save(); octx.strokeStyle='rgba(0,0,0,.35)'; octx.lineWidth=2*DPR(); octx.setLineDash([6*DPR(),6*DPR()]);
    if(eraser.shape==='circle'){ octx.beginPath(); octx.arc(x,y,s/2,0,Math.PI*2); octx.stroke(); } else { octx.strokeRect(x-s/2,y-s/2,s,s); }
    octx.restore();
  }

  // 入力（pointer + mouse/touch フォールバック）
  const OPT = { passive:false };
  function onPointerDown(e){ e.preventDefault(); dbg.down=(dbg.down||0)+1; renderDbg();
    state.pointerId = e.pointerId ?? null; note.setPointerCapture?.(e.pointerId);
    const {x,y} = posFromClient(e.clientX,e.clientY);
    if(state.tool==='eraser'){ useStyle('eraser'); const s=eraser.size*DPR(); if(eraser.shape==='circle'){ctx.beginPath();ctx.arc(x,y,s/2,0,Math.PI*2);ctx.fill();} else {ctx.fillRect(x-s/2,y-s/2,s,s);} guide(x,y); return; }
    useStyle(state.tool); begin(x,y); guide(x,y);
  }
  function onPointerMove(e){ dbg.move=(dbg.move||0)+1; if(e.pointerId&&state.pointerId&&e.pointerId!==state.pointerId) return; const {x,y}=posFromClient(e.clientX,e.clientY);
    if(state.tool==='eraser'){ guide(x,y); if(e.buttons&1){ useStyle('eraser'); const s=eraser.size*DPR(); if(eraser.shape==='circle'){ctx.beginPath();ctx.arc(x,y,s/2,0,Math.PI*2);ctx.fill();} else {ctx.fillRect(x-s/2,y-s/2,s,s);} } return; }
    if(!state.drawing){ guide(x,y); return; } useStyle(state.tool); drag(x,y, e.shiftKey||state.straight); guide(x,y);
  }
  function onPointerUp(e){ dbg.up=(dbg.up||0)+1; if(state.drawing) end(); octx.clearRect(0,0,ov.width,ov.height); try{ if(state.pointerId!=null) note.releasePointerCapture?.(state.pointerId); }catch(_){} state.pointerId=null; renderDbg(); }

  function onMouseDown(e){ if(e.button!==0)return; onPointerDown({...e, pointerId:-1, clientX:e.clientX, clientY:e.clientY, buttons:1, preventDefault:()=>e.preventDefault()}); }
  function onMouseMove(e){ onPointerMove({...e, pointerId:-1, clientX:e.clientX, clientY:e.clientY}); }
  function onMouseUp(e){ onPointerUp(e); }
  function onTouchStart(e){ const t=e.changedTouches[0]; onPointerDown({...e, pointerId:-2, clientX:t.clientX, clientY:t.clientY, buttons:1, preventDefault:()=>e.preventDefault()}); }
  function onTouchMove(e){ const t=e.changedTouches[0]; onPointerMove({...e, pointerId:-2, clientX:t.clientX, clientY:t.clientY}); e.preventDefault(); }
  function onTouchEnd(e){ onPointerUp(e); }

  [note, stage, document].forEach(el=>{
    el.addEventListener('pointerdown', onPointerDown, OPT);
    el.addEventListener('pointermove', onPointerMove, OPT);
    el.addEventListener('pointerup',   onPointerUp,   OPT);
    el.addEventListener('mousedown',   onMouseDown,   OPT);
    el.addEventListener('mousemove',   onMouseMove,   OPT);
    el.addEventListener('mouseup',     onMouseUp,     OPT);
    el.addEventListener('touchstart',  onTouchStart,  OPT);
    el.addEventListener('touchmove',   onTouchMove,   OPT);
    el.addEventListener('touchend',    onTouchEnd,    OPT);
  });

  // Hotkeys（UIは触らず補助のみ）
  addEventListener('keydown',(e)=>{
    if(e.ctrlKey && e.key.toLowerCase()==='e'){ e.preventDefault(); openDlg(); }
    if(e.key==='1') state.tool='pen';
    if(e.key==='2') state.tool='marker';
    if(e.key==='3') state.tool='eraser';
    if(e.key==='Shift') state.straight=true;
    if(e.key.toLowerCase()==='r'){ eraser.shape=eraser.shape==='circle'?'square':'circle'; syncDlg(); }
    if(e.key==='['){ eraser.size=Math.max(4,eraser.size-5); syncDlg(); }
    if(e.key===']'){ eraser.size=Math.min(200,eraser.size+5); syncDlg(); }
    renderDbg();
  });
  addEventListener('keyup',(e)=>{ if(e.key==='Shift') state.straight=false; });

  // 消しゴム設定ダイアログ（内部のみ）
  const dlg = document.getElementById('eraserDialog');
  const $ = id=>document.getElementById(id);
  function openDlg(){ syncDlg(); dlg.showModal?.(); }
  function closeDlg(){ dlg.close?.(); }
  function pxToMm(px){ return px * 25.4 / 96; }
  function syncDlg(){
    $('shapeCircle').setAttribute('aria-pressed', eraser.shape==='circle');
    $('shapeSquare').setAttribute('aria-pressed', eraser.shape==='square');
    $('sizeRange').value = eraser.size;
    $('sizeInfo').textContent = `現在：${eraser.size} px（約 ${(pxToMm(eraser.size)).toFixed(2)} mm）`;
    $('guideOn').setAttribute('aria-pressed', eraser.guide===true);
    $('guideOff').setAttribute('aria-pressed', eraser.guide===false);
  }
  $('shapeCircle').addEventListener('click', ()=>{ eraser.shape='circle'; syncDlg(); });
  $('shapeSquare').addEventListener('click', ()=>{ eraser.shape='square'; syncDlg(); });
  $('sizeDec').addEventListener('click', ()=>{ eraser.size=Math.max(4,eraser.size-5); syncDlg(); });
  $('sizeInc').addEventListener('click', ()=>{ eraser.size=Math.min(200,eraser.size+5); syncDlg(); });
  $('sizeRange').addEventListener('input',(e)=>{ eraser.size=+e.target.value; syncDlg(); });
  $('guideOn').addEventListener('click',()=>{ eraser.guide=true; syncDlg(); });
  $('guideOff').addEventListener('click',()=>{ eraser.guide=false; syncDlg(); });
  $('dlgClose').addEventListener('click', closeDlg);

  // スモークテスト：起動直後に中央へ黒点を1px描画（描けるか確認）
  function smoke(){
    const x = note.width/2, y = note.height/2;
    ctx.save(); useStyle('pen'); ctx.beginPath(); ctx.arc(x,y, 2*DPR(), 0, Math.PI*2); ctx.fillStyle='#000'; ctx.fill(); ctx.restore();
  }

  // 初期化
  dbgInit();
  syncSize();
  smoke(); // 真っ白ならここで中央に小さな黒点が出る

})();
</script>
</body>
</html>
